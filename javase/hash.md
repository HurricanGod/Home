### 散列

构造散列函数原则：
1. 散列的定义域必需包括需要存储的全部关键码，如散列表如果允许有m个地址，则其值域必须在0~m-1
2. 散列函数计算出来的地址应该能均匀发布在整个地址空间
3. 散列函数应是简单的，能在较短时间内计算出结果

>>
>>**散列函数：**<br>
>>1. 除留取余法(散列表中含有的地址数为m,取1个小于m并且最接近m的质数p作为除数，hash(key)=key%p)<br>
>>2. 数字分析法<br>
>>3. 平方取中法<br>
>>4. 折叠法<br>

#### 处理冲突的散列方法
解决冲突的方法又称为**溢出处理技术**   

***闭散列法***（开地址法）
1. 线性探查法

---

当散列表经常变动时，最好不用闭散列法处理冲突，可改用开散列法来处理。因为闭散列情形下是不能随便物理删除表中已有的元素，删除会影响其它元素的搜索。

**线性探查法的问题：**
容易产生**堆积**问题，不同探查序列的关键码占据了可利用的空桶，使得为寻找某关键码需要经历不同的探查序列的元素，导致搜索时间增加。

2. 二次探查法

3. 双散列法
   使用双散列法需要两个散列函数，第1个散列函数Hash()按元素的关键码key计算元素所在桶号；一旦发生冲突，利用第2个散列哈希函数ReHash()计算冲突元素到达“下一个桶”的移位量，这个移位量的取值与key有关，这个移位量应该小于地址空间tablesize并且与tablesize互质。
<br>
<br>若有 H = Hash(key) = key % p
<br>发生冲突时桶号的计算：H[i] = (H[i-1] + ReHash(key)) % p  (i=1,2,3,……n)
<br>
-----

![哈希表](https://github.com/HurricanGod/Home/blob/master/img/hashtable%E9%97%AD%E6%95%A3%E5%88%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png)

***开散列法（链地址法）***

若散列表里的地址为0~m-1，则关键码集合被放在m个子集合中，通过散列函数计算出的具有相同地址的关键码归于同一个集合，同1个集合中的关键码互为同义词，每个子集合为1个桶。

![链地址法解决散列函数冲突](https://github.com/HurricanGod/Home/blob/master/img/open_hashtable.png)

----

散列表的性能主要取决于处理冲突的方法有关。从处理冲突的方法来看，开散列法会好于闭散列法;散列函数中，**除留取余法**作为散列函数会优于其它类型的散列函数；对于有n个关键码的散列表，执行1次搜索或者插入操作，最坏的情况为O(n).
