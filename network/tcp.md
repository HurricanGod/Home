# <a name="top">TCP/IP</a>



`MTU`的概念

> 即最大传输单元，数据帧中数据字段的最大长度，与数据链路层的协议有关。

**以太网**中MAC帧有效长度为`64 ~ 1518`,以太网`MAC`帧格式如下所示：

![](https://github.com/HurricanGod/Home/blob/master/network/img/mac.jpg)

由上图可知，IP协议的所能传输的最大单元为**1500**字节



`RTT` —— 往返时间

> RTT = 数据报从发送端到接收方的时间 + 发送端收到接收端ACK确认的时间

-----

## TCP协议如何实现可靠传输

`TCP`协议通过`ACK`确认和**重传**机制保证数据传输的可靠性，通过分段和序号实现了数据传输的次序。相关的协议有：

+ **停止等待协议** —— 每发送一个分组就停止发送，等待对方的确认，对方确认后在发送下一个分组
+ **连续ARQ协议** —— 每发送一个分组就把**滑动窗口**向前滑动一个分组位置，接收方采用累积确认方式，接收到几个分组后对按序到达的最后一个分组发送确认



### 流量控制

**流量控制**是指接收方将`advertised window`的大小通知给发送方，从而指导发送方修改`offered window`的大小。接收方将该信息放在TCP头部的**窗口区域**。

![]()



### 拥塞控制

**拥塞控制的4种算法**：

+ **慢开始** —— 由小到大逐渐增大拥塞窗口数值，每经过一个传输轮次，拥塞窗口就加倍，拥塞窗口初值为1
+ **拥塞避免** —— 拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口加1
+ **快重传** —— 发送方只要一连收到3个重复`ACk`确认就应当立即重传对方尚未收到的报文段
+ **快恢复** —— 出现拥塞后把门限值减半，执行拥塞避免算法，而不是慢开始算法



TCP中的重传机制：

+ 超时重传
+ 快速重新发送



**快速重新发送** 是指当接收方接收到乱序片段时，需要**重新发送ACK**，当发送方收到ACK值相同的回复达到阀值时，即使**发送方计时器未超时**也需要重新发送空洞对应的片段。



----

## TCP连接管理

+ 3次握手建立连接

  ​





+ 4次挥手关闭连接





----

## <a name="feature">TCP网络特点</a>

+ 发送数据时，如果网络出现问题时，通常能很快检测到网络故障


+ `TCP`最早设计时，当连接上无业务数据传输时，则`TCP`连接自己不会有其它数据传送，所以**当实际的物理链路断之后，如果没有业务数据传送，这时TCP连接也不会检测到网络中断**


+ `TCP`都提供了**keepalive机制**，可以发送心跳包，通常操作系统默认设置的心跳时间都过长，Linux默认为7200秒


+ 当网络中间出现问题后，可能会出现网络通信的两端，其中一端TCP连接还存在于操作系统中，另一端TCP连接已经不存在的情况


+ TCP连接未设置超时机制，当网络真的出现问题时可能会出现卡注的现象




<p align="right"><a href="#">返回</a><a href="#top">返回目录</a></p>



----

**超时注意点**：

+ 客户端连接超时——客户端连接服务端时，需要设置TCP连接超时，否则在网络状态不好的情况下会导致客户端一直处于连接状态


+ 客户端需要设置请求处理超时机制


+ **服务端接收客户端请求超时** —— 服务端收到客户端的前半个数据包，若后半个数据包一直未到达将会一直处于连接状态，需要设置超时机制


+ 服务端处理请求超时机制。如果服务端接收到一个请求后，由于某种原因，无法在一定的时间内完成，应该有一种超时机制中止处理。这个超时时间应该与客户端的超时时间相一致。因为如果客户端执行一个操作，超过指定的时间后，客户端已经中止了，而服务端还在执行这个无用的操作，这时如果客户端继续发起新的请求来，很容易把服务端给压死。


+ 服务端设置空闲连接超时，因为可能存在客户端与服务端建立连接后就再也没有发送过请求的情况，这个TCP连接一直处于空闲状态，若没有空闲连接超时，该TCP连接一直无法释放


+ 客户端数据确认超时。在服务端给客户端发送TCP响应报文时，若网络出现问题服务端可以快速感知到错误，但客户端出现问题，比如收到了数据但一直没有发送确认报文，这将导致服务器hang住


+ 服务端有一个请求队列，应该对队列中的请求也做超时处理，因为超过了一定时间，对客户端已经没有意义了，可以直接从队列中删除掉。**很多服务在正常的压力下，都能提供正常的服务，但当请求稍稍超时正常范围后，就一点都不能提供服务了，多数原因就是没有设置处理超时，导致服务器端一直在处理客户端已超时的无效请求**
