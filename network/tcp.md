# <a name="top">TCP/IP</a>



`MTU`的概念

> 即最大传输单元，数据帧中数据字段的最大长度，与数据链路层的协议有关。

**以太网**中MAC帧有效长度为`64 ~ 1518`,以太网`MAC`帧格式如下所示：

![](https://github.com/HurricanGod/Home/blob/master/network/img/mac.jpg)

由上图可知，IP协议的所能传输的最大单元为**1500**字节



`RTT` —— 往返时间

> RTT = 数据报从发送端到接收方的时间 + 发送端收到接收端ACK确认的时间

-----

## TCP协议如何实现可靠传输

`TCP`协议通过**`ACK`确认**和**重传机制**保证数据传输的可靠性，通过分段和序号实现了数据传输的次序。

相关的协议有：

+ **停止等待协议** —— 每发送一个分组就停止发送，等待对方的确认，对方确认后在发送下一个分组
+ **连续ARQ协议** —— 每发送一个分组就把**滑动窗口**向前滑动一个分组位置，接收方采用累积确认方式，接收到几个分组后对按序到达的最后一个分组发送确认



### 流量控制

**流量控制**是指接收方将`advertised window`的大小通知给发送方，从而指导发送方修改`offered window`的大小。接收方将该信息放在TCP头部的**窗口区域**。

![](https://github.com/HurricanGod/Home/blob/master/network/img/ctr.jpg)



### 拥塞控制

**拥塞控制的4种算法**：

+ **慢开始** —— 由小到大逐渐增大拥塞窗口数值，每经过一个传输轮次，拥塞窗口就加倍，拥塞窗口初值为1
+ **拥塞避免** —— 拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口加1
+ **快重传** —— 发送方只要一连收到3个重复`ACk`确认就应当立即重传对方尚未收到的报文段
+ **快恢复** —— 出现拥塞后把门限值减半，执行拥塞避免算法，而不是慢开始算法



TCP中的重传机制：

+ 超时重传
+ 快速重新发送



**快速重新发送** 是指当接收方接收到乱序片段时，需要**重新发送ACK**，当发送方收到ACK值相同的回复达到阀值时，即使**发送方计时器未超时**也需要重新发送空洞对应的片段。



----

## TCP连接管理

![](https://github.com/HurricanGod/Home/blob/master/network/img/tcp-connect.jpg)

+ 3次握手建立连接

  


`SYN flood`攻击

> 如果恶意向某个服务器发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB从而消耗大量的服务器资源，同时使得正常的TCP连接连接请求无法得到响应。处于监听状态的TCP端口当接受到SYN报文便需要请求分配一个TCB，通常一个TCB至少需要280字节，然后再返回SYN ACK报文进入SYN-RECEIVED即半开连接状态

`SYN flood`防范：

+ 无效连接的监视释放 —— 监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源
+ 延缓TCB分配方法 —— 常见的方法是使用Syn Cache和Syn Cookie技术
  + Syn Cache技术 —— 系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB
  + Syn Cookie技术

----


+ 4次挥手关闭连接

  + 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据
  + 服务端将K值加1向客户端发送一个对FIN报文的确认，同时告知上层应用程序客户端发起了关闭TCP连接的操作
  + 上层应用程序收到客户端关闭TCP连接通知，若不需要发送数据则向客户端发送ack=K+1， Seq=L 的FIN报文
  + 客户端收到服务端发送的FIN报文后，向服务端发送一个ack=L+1的报文，并进入`TIME_WAIT`状态，直到2MSL后TCP连接才真正释放




TCP关闭连接为什么是四次挥手？

> 关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。



主动关闭tcp连接方进入`TIME_WAIT`后为什么还要等待2MSL才真正释放连接？

> 1. 客户端收到服务器发送的FIN报文后需要往服务端发送ACK确认，这个ACK确认可能丢失，服务器不知道客户端是否已经关闭，从而导致服务器无法正常关闭连接；
> 2. 如果短时间内关闭又重新创建了tcp连接，连接的端口刚好跟之前的一样，旧连接尚未消失的报文跟新连接的报文混在一起；
>
> 



----

## <a name="feature">TCP网络特点</a>

+ 发送数据时，如果网络出现问题时，通常能很快检测到网络故障


+ `TCP`最早设计时，当连接上无业务数据传输时，则`TCP`连接自己不会有其它数据传送，所以**当实际的物理链路断之后，如果没有业务数据传送，这时TCP连接也不会检测到网络中断**


+ `TCP`都提供了**keepalive机制**，可以发送心跳包，通常操作系统默认设置的心跳时间都过长，Linux默认为7200秒


+ 当网络中间出现问题后，可能会出现网络通信的两端，其中一端TCP连接还存在于操作系统中，另一端TCP连接已经不存在的情况


+ TCP连接未设置超时机制，当网络真的出现问题时可能会出现卡注的现象




<p align="right"><a href="#">返回</a><a href="#top">返回目录</a></p>



----

**超时注意点**：

+ 客户端连接超时——客户端连接服务端时，需要设置TCP连接超时，否则在网络状态不好的情况下会导致客户端一直处于连接状态


+ 客户端需要设置请求处理超时机制


+ **服务端接收客户端请求超时** —— 服务端收到客户端的前半个数据包，若后半个数据包一直未到达将会一直处于连接状态，需要设置超时机制


+ 服务端处理请求超时机制。如果服务端接收到一个请求后，由于某种原因，无法在一定的时间内完成，应该有一种超时机制中止处理。这个超时时间应该与客户端的超时时间相一致。因为如果客户端执行一个操作，超过指定的时间后，客户端已经中止了，而服务端还在执行这个无用的操作，这时如果客户端继续发起新的请求来，很容易把服务端给压死。


+ 服务端设置空闲连接超时，因为可能存在客户端与服务端建立连接后就再也没有发送过请求的情况，这个TCP连接一直处于空闲状态，若没有空闲连接超时，该TCP连接一直无法释放


+ 客户端数据确认超时。在服务端给客户端发送TCP响应报文时，若网络出现问题服务端可以快速感知到错误，但客户端出现问题，比如收到了数据但一直没有发送确认报文，这将导致服务器hang住


+ 服务端有一个请求队列，应该对队列中的请求也做超时处理，因为超过了一定时间，对客户端已经没有意义了，可以直接从队列中删除掉。**很多服务在正常的压力下，都能提供正常的服务，但当请求稍稍超时正常范围后，就一点都不能提供服务了，多数原因就是没有设置处理超时，导致服务器端一直在处理客户端已超时的无效请求**







------

