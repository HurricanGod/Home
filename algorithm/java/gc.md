## 垃圾回收

**垃圾回收需要完成的事情：**

1. 哪些内存需要回收？
2. 什么时候回收？
3. 如何回收？



### 判断对象是否存活的算法

**引用计数法**

`引用计数法优点：`实现简单，判定效率高

`引用计数法缺点：`难以解决对象间相互引用的问题



**可达性分析算法**

java中采用可达性分析来判断对象是否存活。

<b>算法思想：</b>以“GC Roots”对象为起点，从这些起点出发开始向下搜索，所走过的路径称为`引用链`，不在`引用链`上的对象为不可达对象，这些便是可回收对象



可作为`GC Root`对象的有：

+ 虚拟机栈中引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI（即一般说的Native方法）引用的对象

当对象成为可达性分析算法中不可达的对象时，系统并不会马上释放掉对象，会被进行一次标记，如果该对象覆写了`finalize()`方法，并且虚拟机之前没有调用该方法，，那么这个对象会被放在**F-Queue**队列中，等待低优先级线程Finalizer去执行`finalize()方法`,如果在`finalize()`里把该对象引用交给引用链对象建立关联，则该对象可以逃脱GC

``finalize()方法``只被调用1次

------

永久代的垃圾收集主要回收两部分：`废弃常量`和``无用的类``

> 在大量使用反射、动态代理、Cglib等ByteCode框架这类频繁自定义ClassLoader的场景需要虚拟机具备类卸载功能，以保证永久代不会溢出



**垃圾收集算法**

+ 标记-清除算法
  + 缺点：
    + 标记和清除过程效率都不高
    + 标记-清除算法会产生大量内存碎片
+ 复制算法
  + 缺点：
    + 需要大量内存作为代价
+ 标记-整理算法
+ 分代收集算法



### 垃圾收集器

![垃圾收集器](https://github.com/HurricanGod/Home/blob/master/img/gc.png)
新生代：

+ Serial（单线程）
+ ParNew（并发多线程新生代收集器，适用与多cpu环境）
+ Parallel Scavenge（并行多线程新生代收集器，采用复制算法，适用于吞吐量要求高的环境）
 
老年代：

+ Serial Old（单线程老年代垃圾收集器，采用标记-整理算法）
+ Parallel Old（多线程老年代垃圾收集器，采用标记-整理算法）
+ CMS（并发多线程老年代垃圾收集器，采用标记-清除算法，适用于重视服务的响应速度，希望停顿时间短的环境）
 
<br>新生代——老年代：**G1**

-----

CMS收集器是一款以获取**最短回收停顿时间**为目标的收集器，采用**标记-清除**算法。

运行过程：

1. 初始标记
2. 并发标记（标记进程与用户线程并行执行）
3. 重新标记
4. 并发清除



G1收集器不需要其它收集器配合就能独立管理整个GC堆，，运行期间不会产生内存碎片，收集和能够提供规整的内存空间，把堆划分为多个相等的独立区域，优先回收价值最大的区域，保证在有限的时间内回收效率尽可能高。

运作步骤：

+ 初始标记
+ 并发标记
+ 最终标记
+ 筛选回收



**进行GC时要枚举根节点，用户线程必须暂停才能完成枚举，因此要让用户线程停在合适的暂停点上，这样的暂停点称为安全点，用户线程被暂停时未停在安全点时要让线程继续运行到最近的安全点，有抢占式和非抢占式两种方法使未达安全点的线程到达安全点，此外进行GC时若有些线程本身被悬挂或处于睡眠状态，在枚举根节点时未防止这些特殊状态线程进入执行状态，需要让这些线程在枚举完根节点才能脱离安全区域获取cpu执行权，对于这些进入特殊状态线程需要把它们标记上进入安全区域**



### 内存分配与回收策略

​	对象主要分配的新生代Eden区域，如果启动的**本地线程分配缓冲TLAB**则优先在TLAB分配。

​	当对象在Eden区分配不下时，若对象大小超过虚拟机`-XX:PretenureSizeThreshold`参数配置的大小，则直接在老年代分配，若未超过虚拟机参数配置大小则会触发触发**Minor Gc**，在此之前虚拟机先检查老年代最大连续内存是否能够装得下新生代Eden区和1个Survivor区域中所有对象。

​	如果能够装得下进行1次Minor Gc把新生代Eden区和1个Survivor区域里存活的对象复制到新生代另1个Survivor区域，对象年龄加1，年龄大于老年代晋升阀值的对象进入**老年代** ，对新生代进行垃圾清理后为对象分配内存；若老年代最大连续内存装不下新生代的全部对象，根据虚拟机参数`HandlePromotionFailure`配置是否允许担保失败参数进行下列处理：

1. 如果允许担保失败，虚拟机根据老年代最大连续内存空间是否大于**历次晋升老年代对象的平均大小**决定GC的方式；
   + 最大连续内存空间大于平均值冒险进行1次Minor Gc
   + 小于平均值则进行**Full Gc**
2. 不允许担保失败时直接进行**Full Gc**

