## Java内存模型

**Java内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机将变量存储在内存和从内存中取出变量的这样底层细节**，变量指的是堆中可被共享的，会存在竞争问题的变量

Java内存模型规定所有变量存放在主内存里，**每个线程有自己的工作内存**，工作内存里存放本线程需要使用的变量的主内存副本拷贝，线程对变量的操作必须在工作内存里进行，**不能在主内存里直接对变量进行读写**

**注**

1. 不同线程无法互相访问对方的工作内存
2. 线程间变量值的传递必须通过主内存来完成

----

### Java模型中的8种操作实现主内存与工作内存之间的同步

- lock（锁定）：**作用于主内存的变量**，把它标志为1个线程独占状态
- unlock（解锁）：**作用于主内存的变量**，把处于锁定的变量释放，让其它线程可以加锁
- read（读取）：**作用于主内存的变量**，把变量从主内存传输到工作内存，以便load使用
- load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量放入工作内存的变量副本中
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量传递给执行引擎
- assign（赋值）：作用于工作内存中的变量，把从执行引擎接收到的值赋给工作内存中的变量
- store（存储）：作用于工作内存的变量，把工作内存中的变量送到主内存中，以便write操作使用
- write（写入）：**作用于主内存的变量**，把store操作从工作内存得到的变量值放入到主内存变量中



**8种操作还需要满足的规则**

1. 不允许read和load、store和write操作之一单独出现，即不允许从主内存读取了变量工作内存不接受，工作内存发起写回操作主内存不接受的情况出现
2. 不允许一个线程丢弃它最近的assign操作，工作内存里有了赋值操作必须写回主内存
3. 不允许一个线程无原因地把数据从线程工作内存同步回主内存
4. 新的变量只能在主内存诞生，对1个变量进行use或store操作前必须先执行过assign和load操作
5. 1个变量同一时刻最多允许1个线程对其进行load操作，同一线程可以对1个变量进行多次lock操作，只有执行相同次数的unlock操作变量才会被解锁
6. 对变量执行lock操作会清空工作内存中该变量的值，在执行引擎需要使用此变量前需要先进行load或assign操作
7. 如果没有对变量进行lock操作，就不允许进行unlock操作
8. 对1个变量进行unlock操作前需要把工作内存中变量值同步回主内存


------

## volatile变量

`volatile` 是Java虚拟机提供的**最轻量级的同步机制**

volatile具有的两种特性：

1. 保证此变量对所有线程的可见性，`可见性`是指当1个线程修改了这个变量值，新值对于其它线程来说可以立即得知
2. 使用volatile变量的第二个语义禁止指令重排序优化

**普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，但不能保证变量赋值操作的顺序与程序代码中的执行顺序一样**



***注***

`volatie`虽然**保证线程间的可见性**，但并**不保证原子性**！

下面代码运行结果期望是100000，但结果并没有达到我们的期望，因为`++`操作并不是原子的，存在两个线程a，b同时取了counter的值，并分别加载到了工作内存里，但线程a先对变量counter自加后写回到了主内存，此时线程b的值还是旧值，自加后写回主内存时是较小值。

```java
public class VolatileTest {
    private static volatile int counter = 0;
    public static void main(String[] args) {
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(){
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        counter++;
                    }
                }
            };
            threads[i].start();
        }
        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("counter = " + counter);
    }
}
##################运行结果####################
  ### 结果1：
  counter = 95677
  ### 结果2：
  counter = 89785
```



---

``内存屏障：``指重排序时不能把后面的指令重排序到内存屏障之前的位置

``指令重排序``指cpu采用了允许将多条指令不按程序规定的顺序分发给相应的电路单元处理，要求cpu需要能正确处理指令依赖情况以保证程序能够得到正确的执行结果。

例：

```asm
#指令1： add ax,10
#指令2： mul ax,10
#指令3： add bx,3
```

指令2依赖于指令1，它们的顺序不能颠倒，但指令3可以比指令2先执行，因此把指令3插入到指令2前面并不会影响3条指令执行后的结果



被`volatile`修饰的变量在赋值时的代码在汇编出的指令会多一条以`lock`开头的指令，该指令的作用相当于**内存屏障**， 重排序时不能把**屏障**后面的代码插入到屏障中间。

以 `lock` 前缀开头的指令的作用：

> 使得本CPU的Cache写入内存，该写入操作会引起其它CPU或内核无效化其Cache，这种操作相当于对Cache中的变量做了一次Java内存模型中的store和write操作

``volatile``操作性能与普通变量并没有多少差别，但**写操作**会比普通操作慢，因为它需要往本地代码插入**内存屏障指令**来保证处理器不发生乱序执行。

volatile修饰的变量不会被指令重排序优化，保证代码执行的顺序与程序的顺序相同。

-----

java内存模型围绕并发过程如何处理**原子性**、**可见性**和**有序性**3个特征来建立。

**原子性** ：java内存模型直接保证原子性的变量操作包括read、load、assign、use、store和write，`synchronized`关键字是Java提供更大范围的原子性保证，`synchronized`对应的高层字节码指令为`monitorenter`和`monitorexit`

**可见性** ：java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的依赖主内存为传递媒介的方式来实现内存可见性（**final**和**synchronized**也可实现可见性）

***普通变量***和`volatile`修饰的变量的区别：

+ `volatile`的特殊规则保证了新值能立刻同步到主内存
+ 每次使用 `volatile`变量都是从主内存中读取，多线程环境下保证了变量的可见性，普通变量不能做到这一点

**有序性** ：在本线程中观察，指令执行是有序的；在一个线程里观察另一个线程，所有操作都是无序的；前半句指的是`线程内表现为串行的语义`，后半句指`指令重排`现象和`工作内存与主内存同步延迟`的现象



**java内存中“天然的”先行发生关系**（不会发生指令重排的 `happens-before`原则）

+ ***程序次序规则***
  + 在一个线程里按照控制流顺序书写在前面的操作先发生于书写在后面的操作
+ ***管程锁定规则***
  + unlock操作先发生于后面对同一个锁的lock操作
+ ***volatile变量规则***
  + 对一个volatile变量写操作先行发生于后面对该变量读操作
+ ***线程启动规则***
  + Thread对象的start()方法先行发生于对此线程的每一个动作
+ ***线程终止规则***
  + 线程中的所有操作先行发生于对此线程的终止检测
+ ***线程中断规则***
  + 对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件发生
+ ***对象终结规则***
+ ***传递性***
  + A操作先行发生于B操作，B操作先行发生于C操作，则A操作肯定先行发生于C操作

-----

## Java与线程

**实现线程的3种方式** ：

- 内核线程实现
- 用户线程实现
- 用户线程 + 轻量级进程混合实现

`内核线程实现的缺点：` 线程的创建、析构和同步都需要操作系统调用，系统调用需要在用户态和内核态间转换，代价大，并且操作系统支持的轻量级进程数量有限



`用户线程实现的缺点：`很难解决将用户线程到映射到多处理器系统的处理器上，难以解决线程的调度问题，阻塞等问题

----

`用户线程和轻量级进程混合实现 `：用户线程建立在用户空间，操作系统提供的轻量级进程作为用户线程和内核线程的桥梁，使用内核提供的处理机映射，线程调度，用户线程的调用通过轻量级进程来完成。

**注**

Windows版本和Linux版本使用一对一线程模型实现，把1个Java线程映射到1个轻量级进程里。





