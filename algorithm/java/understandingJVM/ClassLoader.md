## 类加载机制

类从被加载到内存到被卸载的过程的生命周期包括：

1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

这7个过程中，**加载**、**验证**、**准备**、**初始化**、**卸载** 这5个过程顺序是确定，解析阶段则不一定，有可能在初始化阶段再绑定，为了支持运行时绑定。



必须对类进行初始化的5中情况：

1. 用**new**关键字实例化对象，读取或设置类静态成员，调用类方法
2. 使用**java.lang.reflect**对类进行反射调用的时候，类未初始化需先初始化
3. 当初始化一个类其父类未初始化时需要先触发父类初始化
4. 当虚拟机启动时，需要先初始化用户指定的执行主类（包含main的主类）
5. 使用动态语言支持时，如果**java.lang.invoke.MethodHandle** 实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，需要先触发其初始化

-----

### 加载

“加载”是“类加载”的一个阶段，加载阶段需要完成的工作：

+ 通过全限定类名找到获取定义此类的二进制字节流
+ 将此类的二进制字节流所代表静态存储结构转化为方法区的运行时数据结构
+ 在内存里生成1个代表这个此类的**java.lang.Class**对象，作为方法区这个类各种数据的访问入口

**注**

数组类本身不通过类加载器创建，它由java虚拟机直接创建

---

### 验证

验证的目的：确保Class文件的字节流包含的信息符合虚拟机的要求并且包含危害虚拟机自身的安全。

**验证动作主要包含4个验证动作：**

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证


----

### 准备

准备阶段正式为类变量分配内存并设置类变量初值，类变量（用static修饰的）存放在方法区中，类变量的赋值在初始化阶段才会执行。



---

### 解析

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行引用。

**类或接口的解析**



**字段解析**

要解析1个未被解析过的字段符号引用，首先对字段表内的`class_index`项中索引的`CONSTANT_Class_info`符号引用进行解析，如果在解析这个类或接口符号引用过程中出现任何异常将导致字段符号引用解析失败。如果解析完成把这个字段所属的类或接口用C表示：

+ 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用，查找结束
+ 否则在C实现的接口中，按照继承关系从下往上递归搜索各个接口和它的父接口，若找到包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的引用，查找结束
+ 否则，如果C不是Object类，则按照继承关系从下往上递归搜索父类，如果在父类中找到包含简单名称和字段描述符与目标匹配的字段，则返回查找到的字段引用，查找结束
+ 否则，查找失败，抛出异常

如果查找过程返回了引用，还需要对这个字段进行权限验证，如果发现不具备对字段的访问权限将抛出`java.lang.IllegalAccessError`异常



### 接口方法解析



----

### 初始化

初始化主要执行类构造器`<clinit>()`方法的过程，`<clinit>()`方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块`（static { }）`合并产生的，收集的顺序由语句在源文件中位置决定。

**注**

+ 虚拟机会自动调用类构造器`<clinit>()`，不需要显式调用，并且虚拟机保证子类构造器调用前父类的类构造器已经执行，第1个被执行的构造器为`Object类的<clinit>()`
+ 父类中的静态语义块会先于子类的类变量赋值操作
+ 虚拟机保证1个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步


----

### 类与类加载器

绝大部分Java程序都会使用以下3中系统提供的类加载器：

+ 启动类加载器（负责加载将`<JAVA_HOME>\lib`下的类库加载到虚拟机）
+ 扩展类加载器（负责加载将`<JAVA_HOME>\lib\ext`目录下或`java.ext.dir系统变量指定的路径中的类库`加载到虚拟机）
+ 应用程序类加载器（加载用户类路径`ClassPath`上指定的类库）

**双亲委派模型工作过程：**

如果一个类加载器收到类加载请求，首先不会自己去尝试加载该类，而是把加载请求传送给父类加载器完成，每一层的类加载器都是如此，因此所有的请求最终都会传送给顶层类加载器，如果父加载器无法完成加载请求会反馈给子类，子类加载器才会尝试自己去加载。

![](https://github.com/HurricanGod/Home/blob/master/img/ParentsDelegationModel.png)
![](https://github.com/HurricanGod/Home/blob/master/img/classloader.png)

使用**父类委派模式**加载类的原因：

+ 避免重复加载，父类已经加载了该类时，没有必要再用子`ClassLoader`再加载一次
+ 基于安全因素的考虑

