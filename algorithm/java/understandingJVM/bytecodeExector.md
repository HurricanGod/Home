## 虚拟机字节码执行引擎

**栈帧**是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧中存储的主要信息有：

+ 局部变量表
+ 操作数栈
+ 动态连接
+ 方法返回地址

其中**栈帧**中需要**多大的局部变量表**、**多深的操作数栈**在编译时就已经确定；在活动线程中。处于栈顶的栈帧才是有效的栈帧，称为**当前栈帧**，执行引擎的所有字节码指令都只针对当前栈帧进行操作。



-----

### 局部变量表

**用于存放方法参数和方法内定义的局部变量**，局部变量表的容量以**变量槽Slot**为最小单位。



Java中占用32位以内的数据类型有：

1. int
2. short
3. byte
4. char
5. boolean
6. reference
7. float
8. returnType

**注**

`reference`表示对一个对象实例的引用，虚拟机需要对**引用**满足如下两点：

1. 从此引用中直接或间接地查找到对象在堆中数据存放的起始地址索引
2. 可以从此引用中直接或间接地查找到对象所属数据类型在方法区中存储的类型信息

虚拟机如果索引定位的方式使用局部变量表，索引范围从0开始到局部变量表最大的Slot数量。方法执行时，虚拟机**使用局部变量表完成参数变量列表的传递**，如果是执行的是**实例方法**，变量表***第0位索引Slot默认存放的是对象实例引用****，方法中可以通过`this`关键字访问这个隐含参数，其余参数按照参数顺序在局部变量表里依次排序。



**注**

局部变量定义了没有赋初值是不能直接使用，Java中并不是所有变量定义了未赋初值都有默认的值，往往对象才有这一特点。

-----

### 操作数栈

操作数栈的深度在编译期间就已经确定了深度，操作数栈中的元素可以是任意的Java数据类型。方法开始执行时操作数栈深度为空，方法执行过程中字节码指令会往操作栈写入数据和提取数据，**Java指令集是基于栈架构的指令集，指令的执行依靠栈来完成**

----

### 动态连接

每一个栈帧都包含一个指向**运行时常量池**中该栈帧所属方法的引用，持有这个引用的目的是为了支持调用过程中的动态连接。

**Class文件的常量池**中包含大量的符号引用，字节码中的方法调用指令就**以常量池中指向方法的符号引用**作为参数

+ 符号引用在第一次使用或类加载阶段就转化为直接引用的为**静态解析**
+ 在每一次运行期间转化为直接引用的称为**动态解析**



-----

### 方法返回地址

方法执行后，有两种退出方法方式：

+ 正常完成出口
+ 异常完成出口

**正常完成出口：** 遇到方法返回的字节码指令，将返回值传递给上层调用者

**异常完成出口：** 方法执行过程中遇到异常并且**这个异常没有在方法体内处理**，只要本方法的异常表中没有搜索到匹配的异常处理器就会导致方法退出，***不会给上层调用者返回值，返回地址由异常处理器表确定***



**实质**

方法退出的实质是栈顶栈帧出栈，退出可能执行的操作：

+ 恢复上层方法的局部变量表，如果有返回值则返回值压入上层调用者的**操作数栈**中
+ 调整**PC计数器**的值指向方法调用的下一条指令



## 方法调用

**方法调用的唯一任务：** 确定被调用方法的版本（多态下确定调用哪个方法）



Class文件的编译过程不包括传统编译中的**连接**过程，一切方法调用在Class文件里面存储的都是**符号引用**，而不是方法在实际运行时的内存入口地址。



Java语言符合**编译期可知，运行时不可变**要求的方法主要包括4类：

+ 静态方法（与类型直接关联）
+ 私有方法（外部不可访问）
+ 构造方法
+ 父类方法

以上4类方法决定了它们不可能通过**继承**或其它方式`重写其它版本`，只要能被`invokestatic`、`invokespecial`指令调用的方法都可以在**解析阶段**确定***唯一的***调用版本；它们在类加载时就会把符号引用直接解析为该方法的**直接引用**。



**解析调用**： 静态过程，编译期间已经确定，在类装载的解析阶段就会把涉及的符号引用全部转换为可确定的直接引用，不会延迟到运行时再去完成。

**分派调用**： 可能是静态也可能是动态，分为但分派和多分派。

+ 静态分派（与重载相关）
+ 动态分派（与重写相关）

> 所有依赖静态类型来定位方法版本的分派动作称为静态分派，静态分派发生在编译阶段，编译器根据参数的静态类型决定使用那个分派版本。



> 运行期间根据实际类型确定方法执行版本的分派过程称为动态分派



**有时重载版本并不是唯一的，往往只能确定更加适合的版本**，会按照`char->int->long->float->double`顺序自动转型匹配合适的存在版本。

**静态方法可以重载版本，选择重载版本的过程也是通过静态分配完成的**



**invokevirtual**指令运行时多态查找解析过程：

+ 找到操作数栈顶的第一个元素所指向对象的实际类型，记作C
+ 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行权限校验
  + 如果有权限访问直接返回此方法的直接引用
  + 没有权限访问则抛出`java.lang.IllegalAccessError`异常
+ 在类型C里没有找到常量中描述符和简单名称都相符的方法，则自下而上从C的父类中查找
+ 如果始终没有找到合适的方法，抛出`java.lang.AbstractMethodError`异常

**重写**的实质是`invokevirtual`指令把常量池中类方法符号解析到不同的直接引用上。

-----

**虚拟机动态分派的实现**

动态分派是非常频繁的操作，动态分派方法版本的选择过程需要运行时在类的方法元数据中搜索合适的目标方法，虚拟机采用***稳定优化***的手段`为类在方法区建立一个虚方法表`，在`invokeinterface`执行时使用**虚方法表**索引来代替元数据查找以提高性能。



**虚方法表**里存放着各个方法的实际入口地址，如果方法在子类中被重写，子类虚方法表会把该方法的实际入口地址指向子类实现版本的入口地址；如果方法没有被重写，父类方法入口地址和子类方法入口地址都指向同一个地址。

**注**

方法表一般在**类加载连接阶段**初始化，准备了类变量初始值后便把方法表也初始化。

