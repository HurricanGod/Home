# RabbitMQ



----

## 应用场景

+ 异步处理，加快响应速度


+ 应用解耦，将生产者与消费者分开


+ 流量削峰


+ 消息通讯


----

## 概念

+ `Server(broker)`：接收客户端连接，实现`AMQP`消息队列和**路由**功能的进程


+ `Virtual Host`：虚拟主机，用于权限控制，一个`Virtual Host`里可以有若干个`Exchange`和`Queue`


+ `Exchange`：接收生产者发送的消息并根据`Binding`规则将消息路由到服务器队列中，本身不具备消息存储功能


+ `Message Queue`：消息队列，用于存储生产者发送过来的消息


+ `Message`：由`Header`和`Body`组成，***待补充...***


+ `BindingKey`：将`Exchange`与`Queue`绑定起来，绑定的关键字就是`BindingKey`


+ `Connection`：本质上是`TCP`连接


+ `Channel`：信道，基于 `TCP` 连接的上的虚拟连接，负责逻辑上的数据传递，`AMQP`协议规定只有通过`Channel`才能执行`AMQP`命令。



**备注** ：

`RabbitMQ`建议客户端线程之间**不要共用Channel**，至少要保证共用Channel的线程发送消息必须是串行的，但是**建议尽量共用Connection**

-----

## 消息可靠性

+ 消息确认机制


+ 数据持久化




----

+ 消费者消费队列里消息需要与`Rabbit代理服务器`建立一条TCP连接，TCP连接打开后就可以创建`AMQP`信道，信道是建立**真实的**TCP连接内的虚拟连接
+ 每条信道都会被指派一个唯一的ID，`发布消息、订阅队列、接收消息`这些动作都是通过信道完成
+ 为什么不直接通过TCP连接发送AMQP命令？
  + 对于操作系统来说**建立**和**销毁**TCP会话是昂贵的开销
  + 若每发送一个`AMQP命令`都需要进行TCP连接，那么高峰期每秒可能有成千上万条连接，造成TCP连接浪费，而且操作系统每秒可建立的TCP连接数量有限，会导致性能瓶颈





## 队列

创建队列时若未指定队列名，Rabbit将会随机分配一个名称。创建队列可设置的常用参数：

+ `exclusive` 
  + 设置为`true`表示只有当前连接可以连接使用，当前连接关闭时自动删除队列
+ `auto-delete`
  + 设置为`true`时，当最后一个消费者消费完消息时，队列将会被删除
  + 若从来没有消费者连接过队列，队列将不会被删除
  + 若需要临时为单个消费者服务，可以把`auto-delete`设置为**true**，消费者断开连接后队列就会被移除


+ `queue-name`
  + 队列名必须唯一


+ `passive`

  + 如果设置为`true`，创建队列时有同名的队列直接返回，否则返回一个错误

    ​


+ `durable`
  + 若创建队列时把`durable`设置为**true**，队列将会被标记为持久化的。持久化的队列在服务器重启后会自动创建




----

## 交换机

`passive`

- 设置为`true`，创建交换机时若交换机已经存在则返回相同名字的交换机；否则返回一个错误



+ `durable`
  + 创建交换机时若设置为`true`，交换机将会被标记为持久化的，持久化的交换机在服务器重启后将自动创建


+ `auto-delete`
  + 设置为`true`后，所有队列上的消息被消费完后交换机将会被删除
  + 如果交换机已经存在的情况下，使用创建交换机请求即使把`auto-delete`设置为**true**也会被忽略


+ `internal`
  + 如果设置为**true**，生产者将不能使用此交换机，**只能绑定到其它交换机**，不能被外部应用程序使用




------

