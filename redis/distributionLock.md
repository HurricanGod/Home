## 分布式锁

**分布式锁的实现方式**：

+ <a href="#dbLock">数据库乐观锁</a>
+ <a href="#redisLock">基于**Redis**的分布式锁</a>


----

### <a name="redisLock">基于**Redis**的分布式锁</a>

为确保分布式锁的可用，需同时满足以下4个条件：

+ **互斥性** ——任一时刻只有一个客户端能持有锁
+ **不会发生死锁** —— 有一个客户端在持有锁期间崩溃没有主动解锁也能保证后续其它客户端能加锁
+ **容错性** —— 只要大部分`redis`节点正常运行，客户端就可以加锁和解锁
+ 加锁和解锁必须是同一个客户端，客户端不能解别的客户端的锁






----

<a name="dbLock">数据库乐观锁</a>

在数据库中，`lock`和`latch`都可以称为锁，`latch`一般称为门闩（**轻量级的锁**）

+ 在`InnoDB`存储引擎中`latch`分为**互斥锁**(mutex)和**读写锁**(rwlock)，目的是用来保证并发线程操作的正确性
+ `lock`的对象是事务，用来锁定数据库中的对象，如**表、页、行**，并且一般锁的对象仅在事务`commit`或`rollback`后释放





|      |                  lock                  |               latch               |
| :--: | :------------------------------------: | :-------------------------------: |
|  对象  |                   事务                   |                线程                 |
|  保护  |                 数据库内容                  |              内存数据结构               |
| 持续时间 |                 整个事务过程                 |               临界资源                |
|  模式  |               行锁、表锁、意向锁                |              读写锁、互斥量              |
|  死锁  | 通过`waits-for graph、timeout`机制进行死锁检测与处理 | 无死锁检测和处理机制，仅通过应用程序的加锁顺序保证无死锁的情况发生 |



<a href="https://github.com/HurricanGod/Home/blob/master/mysql/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.md#InnodbLock">`InnoDB存储引擎中的锁`</a>



事务分为几种类型：

+ 扁平事务——最简单最频繁使用的事务，由`begin work`开始，由`commit work`或者`rollback work`结束，期间操作是原子的
  + 扁平事务的主要限制是**不能提交或者回滚事务中的某一部分**或**不能分几个步骤提交**
+ 带有保存点的扁平事务——允许在事务执行过程中回滚到同一事务中较早的一个状态
+ 链式事务——在提交1个事务时释放不需要的数据对象，将不要的数据上下文隐式地传给下一个要开始的事务。提交事务和开启下一个事务操作将合并为1个原子操作
+ 嵌套事务
+ 分布式事务——通常是一个在分布式环境下运行的扁平事务，需要**根据数据所在位置**访问网络中的不同节点，**允许多个独立的事务资源参与到一个全局事务中，事务资源可以是关系型数据库系统，全局事务要求参与的事务要么都提交，要么都回滚**



**分布式事务举例**：假设1个用户在ATM进行银行转账操作，如果持卡人从招商银行转账10000元到工商银行储蓄卡。在这种情况下可以将ATM机视为节点A，招商银行后台数据库视为节点B，工商银行后台数据库视为C，转账操作可以细分为：

+ 节点A发出转账命令
+ 节点B执行储蓄卡中的账户余额减10000元
+ 节点C执行储蓄卡账户余额加10000元
+ 节点A通知用户转账完成或转账失败

这里需要使用分布式事务，节点A完成转账需要调用两个不同节点的数据库，而每个节点的数据库执行的事务操作都是扁平的。步骤2，3任何一步失败都会**导致事务回滚**



**事务控制语句**：

+ `start transaction|begin`——显式开启一个事务
+ `commit`
+ `rollback`
+ `savepoint identifier`——允许在一个事务创建1个保存点，1个事务可以有多个保存点
+ `release savepoint identifier`——删除一个事务保存点，如果当前没有保存点可以删除将抛出异常
+ `rollback to savepoint identifier`——把事务回滚到标记点，不回滚到标记点之前的任何操作
+ `set transaction`——用于设置事务隔离级别





使用**分布式事务**时，`InnoDB`存储引擎的事务隔离级别必须设为**可串行化**。

分布式事务由1个或多个资源管理器、1个事务管理器以及一个应用程序组成：

+ **资源管理器**：提供访问事务资源的方法，通常1个数据库就是1个资源管理器
+ **事务管理器**：协调参与全局事务的各个事务，需要与参与全局事务的所有资源进行通信
+ 定义事务的边界，指定全局事务中的操作





分布式事务使用两段式提交方式：

+ **阶段1**：所有参与全局事务的节点都开始准备，告诉事务管理器它们准备好提交
+ **阶段2**：告诉资源管理器执行提交还是回滚





`Mysql`数据库XA事务（分布式事务）的sql语法如下：

```mysql
XA {start|begin} xid [join|resume]
XA END xid [suspend [for migrate]]
XA prepare xid
XA commit xid [one phase]
XA rollback xid
XA recover
```





### 不好的事务习惯

+ 在循环中提交
+ 使用自动提交
+ 使用自动回滚







**参考书籍**

+ `Mysql技术内幕InnoDB存储引擎`