# <a name="top">Redis持久化</a>



+ <a href="#key_expire">`过期键处理策略`</a>


+ <a href="#rdb">`RDB持久化`</a>


+ <a href="#aof">`AOF持久化`</a>


----

## <a name="key_expire">`过期键处理策略`</a>



+ **Redis过期键的判定**
  + 检查给定键是否存在于过期字典中
  + 如果存在，获取过期键的过期时间，检查当前Unix过期时间戳是否大于键的过期时间
  + 如果大于说明键已过期
  + 否则未过期



+ **过期键删除策略**

  + ***定时删除***

    >设置键过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立刻执行对键的删除操作

    + **优点** ：对内存友好，对过期的键尽可能快删除
    + **缺点**：对CPU时间不友好，在CPU紧张时会影响相应时间和吞吐量

    ​

  + ***惰性删除***

    + 放任键过期不管，但是每次在**键空间**读取键时检测键有没有过期，如果过期了直接删除键，没有过期则返回该键
    + **缺点**：过期键如果一直未被访问将永远不会删除，会造成内存泄漏

    ​

  + ***定期删除***

    + 每隔一段时间程序对数据库进行一次检查，删除里面过期的键

    ​

    ​

<p align="right"><a href="#top">目录</a></p>

----

## <a name="rdb">RDB持久化</a>

`Redis`中生成RDB文件的两个命令：

+ `save` —— 会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间不能处理任何命令请求
+ `bgsave` —— 派生1个子进程然后由子进程负责创建RDB文件，**服务器进程会进行处理命令请求**

>执行`save`命令或者`bgsave`命令时会创建一个**新的`RDB`文件**，程序会对数据库中的键进行检查，已过期的键将不会被保存到新创建的RDB文件中



`RDB`方式的持久化是通过快照完成的，通过保存数据库中的键值对来记录数据库状态，当符合一定条件时redis会自动将内存中的所有数据执行快照操作并存储到硬盘上。

配置Redis服务器的save选项，让服务器每隔一段时间执行一次 `bgsave`命令：

```sh
save 900 1
save 300 10
save 60 10000
```

+ 服务器在900s内对数据库进行了至少1次修改将会执行`bgsave`命令
+ 服务器在300s内对数据库进行了至少10次修改将会执行`bgsave`命令
+ 服务器在60s内对数据库进行了至少10000次修改将会执行`bgsave`命令



**RDB文件结构**：

![](https://github.com/HurricanGod/Home/blob/master/redis/img/rdb.jpg)

+ 载入RDB文件时，程序读到`SELECTDB`时就知道接下来要把数据加载到哪个数据库
+ 程序读入`db_number`后，服务器将调用`select`命令切换数据库

-----

### 载入RDB文件

+ RDB文件的载入在服务器启动时只要检测到文件就会自动载入，如果开启了AOF持久化功能，服务器会**优先使用AOF文件**来**还原数据库状态**
+ 服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止


+ 服务器以主服务器模式运行，在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，过期的键会被忽略，过期键对载入RDB文件的主服务器不会造成影响
+ 从模式运行的服务器在载入RDB文件时不管过不过期都载入，主从服务器进行数据同步时，从服务器的数据就会被清空，过期键对载入RDB文件的从服务器不会造成影响




**优点**：
+ 文件紧凑，适合备份、全量复制场景
+ Redis加载RDB文件恢复数据比AOF快


**缺点**：
+ 无法秒级持久化，存在数据实时性问题


<p align="right"><a href="#top">目录</a></p>

----

## <a name="aof">AOF持久化</a>



+ `AOF`持久化的方式是通过**保存Redis所执行的写命令**来记录数据库状态，被写入`AOF`文件的所有命令都是以Redis的命令请求协议格式保存
+ 默认情况下redis没有开启aof，可以通过参数**appendonly**参数开启


+ 执行 `AOF` 重写过程中，程序会对数据库中的键进行检查，**已过期**的key不会被保存到重写后的`AOF`文件中
+ 过期键被惰性删除或定时删除，程序会先`AOF`文件追加一条删除命令


+ 服务器在启动时可以通过载入和执行`AOF`文件中的保存的命令来还原服务器之前的数据库状态



**AOF持久化功能的实现可以分为三个步骤**：

+ 命令追加 

  > AOF持久化功能开启时，服务器执行完一个写命令后会以协议格式将被执行的的写命令追加到服务器状态的`aof_buf`缓冲区的末尾

  ​

+ 文件写入

> Redis服务器进程是一个事件循环，循环中的文件事件负责接收客户端命令请求，执行写命令的同时会把内容添加的 aof_buf 缓冲区末尾，服务器每次结束一个事件循环时会判断是否需要调用 flushAppendOnlyFile函数将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里
>
> flushAppendOnlyFile函数的行为由服务器配置参数 appendfsync 选项决定

​	

| appendfsync选项的值 | flushAppendOnlyFile函数的行为                 | 效率和安全性                       |
| :-------------- | :--------------------------------------- | :--------------------------- |
| `always`        | 将`aof_buf`缓冲区中的所有内容**写入并同步**到AOF文件       | 效率低，安全性高                     |
| `everysec`      | 1.  将 `aof_buf` 缓冲区的内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1s，则对AOF文件进行同步<br/>2.  同步操作是由专门线程负责 | 效率高，最多丢失1s的命令数据              |
| `no`            | 将 `aof_buf` 缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，**何时同步由操作系统决定** | 效率高，写入AOF文件的速度最快，单次同步时长通常比较长 |

> 为提高文件的写入效率，现代操作系统中当用户调用 write 函数将一些数据写入到文件时，操作系统会将写入的数据占时保存到一个内存缓存区里面，等到缓冲区的空间被填满或者超过指定时限后，才真正将缓冲区的内容写入磁盘里



+ 文件同步




----

### AOF重写

**背景**：

`AOF`持久化是通过保存执行的**写命令**来记录数据库的状态，随着服务器的运行时间的流逝，AOF文件的内容会越来越多，文件体积越来越大，导致使用AOF文件还原数据库的时间越长。



`Redis`提供AOF文件重写的功能来解决AOF文件膨胀的问题，通过创建新的AOF文件替代现有的AOF文件，新旧两个AOF文件保存的数据库状态相同，新的AOF文件不包含任何浪费空间的冗余命令。





**AOF文件重写实现**：

`AOF`文件重写并不需要对现有的AOF文件进行任何的读取、分析以及写入操作，实现是基于服务器当前的数据库状态实现的。重写时从数据库中读取键当前的值，然后使用一条命令记录键值对代替之前记录这个键值对的多条命令。



**AOF后台重写**：

Redis将AOF后台重写程序放在子进程里执行，这样做的目的是：

+ 子进程在AOF重写期间，服务器进程可以继续处理命令请求
+ 子进程带有服务器进程的数据副本，可以在避免使用锁的情况下保证数据的安全性



`AOF`重写过程需要解决的问题：

> 子进程在进行AOF重写期间，服务器进程还需要接受客户端请求继续执行命令，新的命令可能会改变数据库现有状态，从而导致重写后AOF文件所保持数据库状态与当前数据库状态不一致。

**解决方法**：

Redis服务器设置一个`AOF重写缓冲区`，这个缓冲区在创建子进程之后开始使用，当Redis服务器执行完一个写命令后，同时将这个写命令发送给`AOF重写缓冲区`和`AOF缓冲区`。



**子进程执行AOF文件重写期间**，服务器进程执行以下3个工作：



+ 执行客户端发来的命令
+ 将执行后的写命令追加到`AOF缓冲区`
+ 将执行后的写命令添加到`AOF重写缓冲区`

![](https://github.com/HurricanGod/Home/blob/master/redis/img/aof-rewrite.jpg)

------

**子进程完成AOF文件重写后**，会向服务器进程发送信号，服务器进程接收到信号后会调用信号处理函数，执行以下内容：

+ 将**AOF重写缓冲区**中的所有内容写入到新的AOF文件中，这就保证了AOF文件保存的数据库状态与服务器当前服务器状态一致了
+ 对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧AOF文件的替换

整个AOF重写过程只有执行信处理函数过程中会对服务器进程造成阻塞，其它情况均不会影响服务器接收客户端请求执行命令


**AOF持久化的优点**：
+ 数据实时性高

<p align="right"><a href="#top">目录</a></p>
